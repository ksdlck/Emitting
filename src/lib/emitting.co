ex = exports? and exports or window

class ex.Emitting
  on: (ev, proc)->
    ev = [ev] if typeof ev is \string
    spec = @.@evs
    for c of ev
      switch typeof c
        case \string
          next = spec.@s.@[c]
        case \number
          next = spec.@n.@[c]
      spec = next
    spec.@@p.push proc
    @
  off: (ev, proc)->
    ev = [ev] if typeof ev is \string
    spec = @.@evs
    for c of ev
      ctype = typeof c is \string and \s or \n
      dobj? or [dobj, dprop] = [spec, ctype]
      spec = (ref = spec[ctype]) and ref[c]
      if not spec
        dobj = null
        break
      dobj = null if (p for p in ref).length is not 1
      dobj? or [dobj, dprop] = [ref, c]
    spec.p and for i from 0 til spec.p.length
      if spec.p[i] is proc
        spec.p.splice i--, 1
    dobj = null if spec.p.length is not 0
    delete dobj[dprop] if dobj
    @
  _emit: !(ev, idx, spec, args)->
    if ev.length - idx is 0
      spec.p and for proc of spec.p
        proc ...args
    spec.s and (next = spec.s[ev[idx]]) and @_emit ev, idx + 1, next, args
    spec.n and for num in spec.n
      next = spec.n[num]
      num = parseInt num
      if num is 0
        for i from idx to ev.length
          @_emit ev, i, next, args
      else if idx + num <= ev.length
        @_emit ev, idx + num, next, args
      else
        break
  emit: (ev, ...args)->
    # TODO roll the recursive emit process into a queue
    # TODO add a few short circuits to the variable matcher
    ev = [ev] if typeof ev is \string
    @_emit ev, 0, @.@evs, args
    @
  many: (ev, times, proc)->
    _proc = !~>
      proc ...
      if --times is 0
        @off ev, _proc
    @on ev, _proc
  one: !(ev, proc)->
    _proc = !~>
      proc ...
      @off ev, _proc
    @on ev, _proc
